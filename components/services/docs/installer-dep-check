
ensure_deps_helper (GList &packages, GList &failedpackages)
1. load package headers for unloaded, bind packages[x] to header[x], set state to unresolved
2. add to transaction set
3. depcheck
4. if ok - return (failedpackages = NULL)
   if fail - ensure_deps_are_fetched (packages, &tmp_extra, &tmp_failed)
	     5. add tmp_extra to packages
             6. if tmp_failed - prune_packages (tmp_failed, packages, failedpacakges)
7 call ensure_deps_helper (packages, &failedpackages)

ensure_deps (GList &packages, GList &failedpackages)
1. copy pacakges into tmp
2. ensure_deps_helper (tmp, tmp_failed)
3. for each (packages) if in tmp_failed 
		4 emit_signal
		5 remove from tmp_failed
		6 move from packages to failedpackages
7. for each (tmp_failed)
		8. delete	


rpm_install (GList packages)
   |
   |- while ( (state = ensure_deps (&packages, &out_files))  == rerun) { 
   |              |                                                        merge packages with outfiles
   |              |                                                        free outfiles
   |              |                                                     }
   |              |
   |              |- add files to TransactionSet
   |              |- dep order
   |              |- dep_check
   |                   if ok
   |                       |- free stuff, and return ok
   |                   if fail 
   |                       |- free stuff
   |                       |- loop dep_conflicts {
   |                       |     |- call state = fetch_packages (dep_conflicts[x])
   |                       |     |                  |- http_fetch or such, dep on topts
   |                       |     |- if (state == no_matching) 
   |                       |     |       |- emit signal install_failed (package, DEP_FAIL)
   |                       |     |       |- remove from packages
   |                       |     |- if (state == ok)
   |                       |             |- add conflicts to out_files
   |                       |- return rerun
   |
   |- do_rpm_install (packages)
         |- read headers
         |      if (source)
         |       |- emit signal install_failed (package, DEP_SRC_NO_SUPPORTED)
         |
         |- add to set
         |- run transaction set


GList *load_rpm_headers (GList *packages) {
}

free_rpm_header_list (GList *headers);

gboolean is_source_rpm (struct header header) {
}

add_headers_to_transaction_set (GList *headers, rpmTransactionSet set) {
}

bool ensure_deps_are_fetched (service, GList **packages, GList **output_files) {
}

bool rpm_install (service, GList *packages) {
}

bool fetch_deps (service, struct DepConflicts, int num_conflicts) {
}

bool do_rpm_install (service, GList filename) {
}


-----------------------
fetch_packages (service, packages, conflicts, &failedpackages)
  |
  |-for_each conflict {
        |- packagedata *pack = packagedata from packages that matches conflict[0];
        |- call http_fetch_file_with_special_tricky_url
